<?php
/**
* @package shorty an ownCloud url shortener plugin
* @category internet
* @author Christian Reiner
* @copyright 2011-2014 Christian Reiner <foss@christian-reiner.info>
* @license GNU Affero General Public license (AGPL)
* @link information http://apps.owncloud.com/content/show.php/Shorty?content=150401
*
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
* License as published by the Free Software Foundation; either
* version 3 of the license, or any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU AFFERO GENERAL PUBLIC LICENSE for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this library.
* If not, see <http://www.gnu.org/licenses/>.
*
*/

/**
 * @file relay.php
 * This is the plugins central relaying feature
 * All relay requests are handled by this file.
 * @access public
 * @author Christian Reiner
 */

// swallow any accidential output generated by php notices and stuff to preserve a clean JSON reply structure
OC_Shorty_Tools::ob_control ( TRUE );

// Session checks
OCP\App::checkAppEnabled ( 'shorty' );

$RUNTIME_NOSETUPFS = true;
OCP\App::setActiveNavigationEntry ( 'shorty_index' );

$arg = NULL;
// we try to guess what the request indicates:
// - a (shorty) id to be looked up in the database resulting in a forwarding to the stored target
// - a (target) url to be added as a new shorty
// - none of the two, so just a plain list of existing shortys
foreach ($_GET as $key=>$val) // in case there are unexpected, additional arguments like a timestamp added by some stupid proxy
{
	switch ($key)
	{
		default:
			// unrecognized key, we ignore it
			break;

		case 'id':
		case 'shorty':
		case 'ref':
		case 'entry':
			// a recognized argument key indicating an id to be looked up
			$arg = OC_Shorty_Type::req_argument($key,OC_Shorty_Type::ID,FALSE);
			break 2; // skip switch AND foreach
	} // switch
} // foreach

// swallow any accidential output generated by php notices and stuff to preserve a clean JSON reply structure
OC_Shorty_Tools::ob_control ( FALSE );

// now construct the target url and relay to it (if applicable)
try
{
	// has an id been specified at all ?
	if ( NULL==$arg )
	{
		// nothing to forward to => 400: Bad Request
		throw new OC_Shorty_HttpException ( 400 );
	}
	// an id was specified, ordinary or special meaning ?
	if ( '0000000000'==$arg )
	{
		// this is a pseudo id, used to test the setup, so just return a positive message.
		// this is used to test the setup of the static backend, shorty calls itself from there
		OCP\Util::writeLog( 'shorty', "Positiv validation of static backend base url.", OCP\Util::DEBUG );
		// we have to react to a jsonp request, so we have to reply valid jsonp manually:
		// note that we use 'static' jsonp, so no callback parameter is provided, instead it is hard coded here
		// this reduces the complexity of setting up the backend, since no additional parameter has to be handled
		echo sprintf ( 'verifyStaticBackend(%s)', json_encode(array('status'=>'success')) );
		exit();
	}

	// detect requested shorty id from request
	$p_id = trim ( OC_Shorty_Type::normalize($arg,OC_Shorty_Type::ID) ) ;
	if ( $p_id )
	{
		$param   = array ( 'id' => $p_id );
		$query   = OCP\DB::prepare ( OC_Shorty_Query::URL_RELAY );
		$result  = $query->execute($param)->FetchAll();
		$request = array (
		'address' => $_SERVER['REMOTE_ADDR'],
		'host'    => isset($_SERVER['REMOTE_HOST'])?$_SERVER['REMOTE_HOST']:gethostbyaddr($_SERVER['REMOTE_ADDR']),
		'time'    => $_SERVER['REQUEST_TIME'],
		'user'    => OCP\User::getUser(),
		);
		if ( FALSE===$result )
			throw new OC_Shorty_HttpException ( 500 );
		elseif ( ! is_array($result) )
			throw new OC_Shorty_HttpException ( 500 );
		elseif ( 0==sizeof($result) )
		{
			// no entry found => 404: Not Found
			throw new OC_Shorty_HttpException ( 404 );
		}
		elseif ( 1<sizeof($result) )
		{
			// multiple matches => 409: Conflict
			throw new OC_Shorty_HttpException ( 409 );
		}
		elseif ( (!array_key_exists(0,$result)) || (!is_array($result[0])) || (!array_key_exists('target',$result[0])) )
		{
			// invalid entry => 500: Internal Server Error
			throw new OC_Shorty_HttpException ( 500 );
		}
		elseif ( (!array_key_exists('target',$result[0])) || ('1'==$result[0]['expired']) )
		{
			// entry expired => 410: Gone
			throw new OC_Shorty_HttpException ( 410 );
		}
		// an usable target !
		$target = trim($result[0]['target']);
		// check status of matched entry
		switch (trim($result[0]['status']))
		{
			default:
			case 'blocked':
				// refuse forwarding => 403: Forbidden
				OC_Shorty_Hooks::registerClick ( $result[0], $request, 'blocked' );
				throw new OC_Shorty_HttpException ( 403 );

			case 'private':
				// check if we are already logged in
				if (  ( ! OCP\User::isLoggedIn() )
						||( $result[0]['user']!=OCP\User::getUser()) )
				{
					if (   ! isset($_SERVER['PHP_AUTH_USER'])) {
						header('WWW-Authenticate: Basic realm="OwnCloud relay authorization"');
						header('HTTP/1.0 401 Unauthorized');
						// important: flush, so that auth headers are not swallowed by OC
						flush(); ob_flush();
						// refuse forwarding => 403: Forbidden
						OC_Shorty_Hooks::registerClick ( $result[0], $request, 'failed' );
						throw new OC_Shorty_HttpException ( 403 );
					}
					elseif ( ! OCP\User::checkPassword($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) )
					{
						header('WWW-Authenticate: Basic realm="Retry OwnCloud relay authorization"');
						header('HTTP/1.0 401 Unauthorized');
						// important: flush, so that auth headers are not swallowed by OC
						flush(); ob_flush();
						// refuse forwarding => 403: Forbidden
						OC_Shorty_Hooks::registerClick ( $result[0], $request, 'failed' );
						throw new OC_Shorty_HttpException ( 403 );
					}
					elseif ( $result[0]['user']!=$_SERVER['PHP_AUTH_USER'] )
					{
						// refuse forwarding => 403: Forbidden
						OC_Shorty_Hooks::registerClick ( $result[0], $request, 'denied' );
						throw new OC_Shorty_HttpException ( 403 );
					}
				}
				break;

				case 'shared':
				// check if we are already logged in
				if ( ! OCP\User::isLoggedIn() )
				{
					if (   ! isset($_SERVER['PHP_AUTH_USER'])) {
						// first, non-authenticated attempt, request authentication
						header('WWW-Authenticate: Basic realm="OwnCloud relay authorization"');
						header('HTTP/1.0 401 Unauthorized');
						// important: flush, so that auth headers are not swallowed by OC
						flush(); ob_flush();
						// fallback: refuse forwarding => 403: Forbidden
						OC_Shorty_Hooks::registerClick ( $result[0], $request, 'failed' );
						throw new OC_Shorty_HttpException ( 403 );
					}
					elseif ( ! OCP\User::checkPassword($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) )
					{
						// second, authenticated attempt, request repeated authentication
						header('WWW-Authenticate: Basic realm="Retry OwnCloud relay authorization"');
						header('HTTP/1.0 401 Unauthorized');
						// important: flush, so that auth headers are not swallowed by OC
						flush(); ob_flush();
						// log denied access attempt
						OC_Shorty_Hooks::registerClick ( $result[0], $request, 'failed' );
						// fallback: refuse forwarding => 403: Forbidden
						throw new OC_Shorty_HttpException ( 403 );
					}
				}
				break;

				case 'public':
				// no access restriction, so all fine!
		} // switch status

		// finish this script to record the click, even if the client detaches right after the redirect
		ignore_user_abort ( TRUE );
		// register click
		OC_Shorty_Hooks::registerClick ( $result[0], $request, 'granted' );
		// forward to target, regardless of who sends the request
		header("HTTP/1.0 301 Moved Permanently");
		// http forwarding header
		header ( sprintf('Location: %s', $target) );
	} // if id
} catch ( OC_Shorty_Exception $e ) { header($e->getMessage()); }
?>
